- ORM
  - 정의
    - 객체 지향 프로그래밍의 **객체**와 관계형 데이터베이스의 **테이블**을 자동으로 매핑해주는 기술
    - 프로그래밍 언어의 객체와 데이터베이스의 관계를 연결해주는 다리 역할
  - 등장 배경
    - 객체 지향적 설계와 관계형 데이터베이스 간의 **패러다임 불일치** 해결 필요성
    - SQL 쿼리 작성의 반복적인 작업 감소 및 생산성 향상 요구
    - 데이터베이스 벤더(MySQL, Oracle 등) 종속성 해결 필요
  - 주요 특징
    - **객체-테이블 매핑**
      - 클래스는 테이블과 매핑
      - 객체의 필드는 테이블의 컬럼과 매핑
      - 기본키(Primary Key)와 외래키(Foreign Key) 관계도 객체 간의 참조로 매핑
    - **영속성(Persistence) 관리**
      - 데이터의 상태 변화를 자동으로 감지하고 데이터베이스에 반영
      - 캐싱을 통한 성능 최적화 지원
    - **트랜잭션 관리**
      - 데이터베이스 작업의 원자성(Atomicity) 보장
      - 일관성 있는 데이터 처리 지원
- Prisma 문서 살펴보기
  - 정의
    - Node.js와 TypeScript를 위한 **차세대 ORM**으로, 직관적인 데이터 모델링과 타입 안전성을 제공하는 데이터베이스 툴킷
    - **선언적 스키마 정의**와 자동 생성되는 타입-세이프 클라이언트가 특징
  - 주요 구성 요소
    - **Prisma Schema**
      - 데이터 모델을 정의하는 선언적 파일
      - 데이터베이스 연결 설정과 모델 정의를 단일 파일에서 관리
    - **Prisma Client**
      - 자동 생성되는 타입-세이프 데이터베이스 클라이언트
      - intellisense와 자동완성 지원으로 개발 생산성 향상
    - **Prisma Migrate**
      - 데이터베이스 스키마 버전 관리 도구
      - 스키마 변경 이력을 마이그레이션 파일로 관리
  - CRUD 작업 특징
    - **Create**
      - 단일 레코드 생성은 `create` 메서드로 직관적 수행
      - 다중 레코드 생성은 `createMany`로 벌크 작업 지원
    - **Read**
      - `findUnique`로 단일 레코드 조회
      - `findMany`로 필터링, 정렬, 페이지네이션 지원
      - 관계 데이터는 `include`나 `select`로 세밀한 제어
    - **Update**
      - `update`로 단일 레코드 수정
      - `updateMany`로 조건에 맞는 다수 레코드 일괄 수정
      - 트랜잭션 내에서 원자적 업데이트 보장
    - **Delete**
      - `delete`로 단일 레코드 삭제
      - `deleteMany`로 조건부 대량 삭제 수행
      - 참조 무결성 자동 처리
  - ex. Prisma의 Connection Pool 관리 방법
    Connection Pool 관리
    - **정의**
      - 데이터베이스 연결을 효율적으로 재사용하기 위한 관리 시스템
    - **주요 설정**
      - `connection_limit`: 최대 동시 연결 수 설정
      - `pool_timeout`: 연결 대기 시간 제한
      - `idle_timeout`: 유휴 연결 유지 시간
    - **최적화 전략**
      - 애플리케이션 규모에 따른 적절한 풀 사이즈 설정
      - 부하 테스트를 통한 최적 값 도출
      - 모니터링을 통한 연결 상태 관리
  - ex. Prisma의 Migration 관리 방법
    Migration 관리
    - **작동 방식**
      - 스키마 변경 사항을 감지하여 마이그레이션 파일 자동 생성
      - 변경 이력을 SQL 파일로 버전 관리
    - **주요 명령어 개념**
      - `migrate dev`: 개발 환경에서 마이그레이션 생성 및 적용
      - `migrate deploy`: 프로덕션 환경에서 보류 중인 마이그레이션 적용
      - `migrate reset`: 데이터베이스 초기화 및 모든 마이그레이션 재적용
    - **모범 사례**
      - 마이그레이션 파일의 버전 관리 시스템 통합
      - 롤백 계획 수립
      - 데이터 손실 방지를 위한 백업 전략 수립
- ORM(Prisma)을 사용하여 좋은 점과 나쁜 점
  ORM(Prisma) 사용의 장단점
  - 장점
    - **타입 안전성**
      - TypeScript와의 완벽한 통합으로 컴파일 타임에 오류 감지
      - 자동 완성과 인텔리센스 지원으로 개발 생산성 향상
    - **직관적인 API**
      - SQL 작성 없이 메서드 체이닝으로 쿼리 작성 가능
      - 복잡한 관계 데이터도 단순한 문법으로 처리
      ```tsx
      typescript;
      Copy;
      // 예: user와 관련된 posts를 조회
      const userWithPosts = await prisma.user.findUnique({
      	include: { posts: true },
      });
      ```
    - **스키마 관리 용이**
      - 단일 스키마 파일로 데이터베이스 구조 파악 용이
      - 마이그레이션 자동화로 버전 관리 편리
  - 단점
    - **성능 오버헤드**
      - 복잡한 쿼리의 경우 자동 생성된 SQL이 비효율적일 수 있음
      - 특히 대량의 데이터 처리 시 Raw SQL보다 느릴 수 있음
    - **학습 곡선**
      - Prisma만의 독특한 스키마 문법 학습 필요
      - 관계 설정과 마이그레이션 관리에 대한 이해 필요
    - **제한된 유연성**
      - 특정 데이터베이스 기능 사용에 제약이 있을 수 있음
      - 커스텀 SQL 실행 시 별도의 처리 필요
- 다양한 ORM 라이브러리 살펴보기
  - ex. Sequelize
    - 정의
      - Node.js 생태계에서 가장 오래되고 안정적인 ORM
      - **Promise 기반**의 비동기 작업 처리 특화
    - 주요 특징
      - **다양한 데이터베이스 지원**
        - MySQL, PostgreSQL, SQLite, Microsoft SQL Server 등
        - 데이터베이스 전환이 용이
      - **모델 정의 방식**
        - JavaScript 클래스 기반의 모델 정의
        - 데코레이터 없이 순수 JS/TS 객체로 정의 가능
      - **쿼리 인터페이스**
        - 체이닝 방식의 직관적인 쿼리 빌더
        - Raw SQL 쿼리 지원으로 유연성 제공
  - ex. TypeORM
    - 정의
      - TypeScript로 작성된 **객체 지향적 ORM**
      - 데코레이터 패턴을 활용한 선언적 모델 정의
    - 주요 특징
      - **강력한 타입 지원**
        - TypeScript와의 완벽한 통합
        - 컴파일 타임 타입 체크
      - **Entity 관계 설정**
        - JPA 스타일의 데코레이터 기반 관계 매핑
        - 양방향 관계 설정 용이
      - **마이그레이션 시스템**
        - 자동 마이그레이션 생성
        - CLI 도구를 통한 마이그레이션 관리
- 페이지네이션을 사용햐는 다른 API 찾아보기
  - 커서 기반 페이지네이션
  - 오프셋 기반 페이지네이션
  - ex. https://docs.github.com/en/rest/using-the-rest-api/using-pagination-in-the-rest-api?apiVersion=2022-11-28
  - ex. https://developers.notion.com/reference/intro#pagination
